import telebot
import requests
import random
import json
import re
from telebot.types import InlineKeyboardMarkup, InlineKeyboardButton, InputMediaPhoto
from concurrent.futures import ThreadPoolExecutor
from flask import Flask, request
import threading
import time
import os

# ØªÙ‡ÙŠØ¦Ø© Flask app Ù„Ù„ÙˆÙŠØ¨ Ù‡ÙˆÙˆÙƒ
app = Flask(__name__)

# APIs
SeedReam = "https://sii3.top/api/SeedReam-4.php"
DEEPSEEK_V3_API = "https://sii3.top/api/deepseek.php?v3="
DEEPSEEK_R1_API = "https://sii3.top/api/deepseek.php?r1="

# Token Ø§Ù„Ø¨ÙˆØª
BOT_TOKEN = "8293003270:AAGf2GQvucNgi5fLbgBSpPHr-iKmMUp7l9U"
T = telebot.TeleBot(BOT_TOKEN)

# Ø¥Ø¹Ø¯Ø§Ø¯ ÙˆÙ‚Øª Ø£Ø·ÙˆÙ„ Ù„Ù„Ø·Ù„Ø¨Ø§Øª
import requests
requests.adapters.DEFAULT_TIMEOUT = 60

# Ù‚Ù†Ø§Ø© Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ø¥Ø¬Ø¨Ø§Ø±ÙŠ
CHANNEL_USERNAME = "@iIl337"

# ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
user_photos = {}
user_action = {}

# Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„ØªØ¹Ø¨ÙŠØ±ÙŠØ© Ø§Ù„Ø¹Ø´ÙˆØ§Ø¦ÙŠØ©
emojis = ["ğŸªº", "ğŸŒ´", "ğŸ‹", "ğŸ˜•", "ğŸŒ¼", "ğŸ””", "ğŸŒ»", "ğŸ‘‹", "ğŸŒ³", "ğŸ€", "ğŸŒ¾", "ğŸ»", "ğŸ¹", "ğŸ¥", "ğŸŸ¡", "ğŸ", "ğŸ–¤", "ğŸªµ", "ğŸï¸", "â™¥ï¸", "â£ï¸", "â¤ï¸â€ğŸ©¹", "ğŸ«’", "ğŸŒš", "ğŸ’", "ğŸ«€"]

def get_random_emoji():
    """Ø¥Ø±Ø¬Ø§Ø¹ Ø±Ù…Ø² ØªØ¹Ø¨ÙŠØ±ÙŠ Ø¹Ø´ÙˆØ§Ø¦ÙŠ"""
    return random.choice(emojis)

def check_subscription(user_id):
    """Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©"""
    try:
        chat_member = T.get_chat_member(CHANNEL_USERNAME, user_id)
        return chat_member.status in ['creator', 'administrator', 'member']
    except:
        return False

def clean_prompt_text(text):
    """ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù†Øµ Ù…Ù† Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠØ© ÙˆØ­Ù‚ÙˆÙ‚ Ø§Ù„Ù…Ø·ÙˆØ±ÙŠÙ† Ø¨Ø´ÙƒÙ„ ÙƒØ§Ù…Ù„"""
    # Ø¥Ø²Ø§Ù„Ø© Ø¬Ù…ÙŠØ¹ Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„ÙƒÙˆØ¯ ÙˆØ§Ù„ØªÙ†Ø³ÙŠÙ‚Ø§Øª Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠØ©
    cleaned = text.replace('```', '').replace('`', '').replace('***', '').replace('---', '').strip()
    
    # Ø¥Ø²Ø§Ù„Ø© Ø£ÙŠ Ø­Ù‚ÙˆÙ‚ Ù…Ø·ÙˆØ±ÙŠÙ† Ø£Ùˆ Ø¥Ø¹Ù„Ø§Ù†Ø§Øª Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ØªØ¹Ø§Ø¨ÙŠØ± Ø§Ù„Ù†Ù…Ø·ÙŠØ©
    patterns_to_remove = [
        r'.*[Cc]hannel.*',
        r'.*[Ss]upport.*', 
        r'.*[Ss]ubscribe.*',
        r'.*[Dd]eveloper.*',
        r'.*[Dd]ev.*',
        r'.*ØªØ§Ø¨Ø¹.*',
        r'.*Ù‚Ù†Ø§Ø©.*',
        r'.*Ø¯Ø¹Ù….*',
        r'.*Ù…Ø·ÙˆØ±.*',
        r'.*@\w+.*',
        r'^---.*',
        r'^###.*',
        r'.*Note:.*',
        r'.*Adjust these.*',
        r'.*Midjourney.*',
        r'.*DALL-E.*',
        r'.*Stable Diffusion.*',
        r'.*--ar.*',
        r'.*--style.*'
    ]
    
    lines = cleaned.split('\n')
    clean_lines = []
    
    for line in lines:
        line = line.strip()
        if not line:
            continue
            
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¹Ø¯Ù… ØªØ·Ø§Ø¨Ù‚ Ø§Ù„Ø®Ø· Ù…Ø¹ Ø§Ù„Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ù…Ø±ÙÙˆØ¶Ø©
        should_skip = False
        for pattern in patterns_to_remove:
            if re.match(pattern, line, re.IGNORECASE):
                should_skip = True
                break
                
        if not should_skip:
            clean_lines.append(line)
    
    # ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ù†Øµ Ø§Ù„Ù†Ø¸ÙŠÙ
    final_text = '\n'.join(clean_lines).strip()
    
    # Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù†Øµ Ù‚ØµÙŠØ±Ø§Ù‹ Ø¬Ø¯Ø§Ù‹ØŒ Ù†Ø¹ÙŠØ¯ Ù†ØµØ§Ù‹ Ø¨Ø¯ÙŠÙ„Ø§Ù‹
    if len(final_text) < 20:
        return "Create a professional, high-quality image with detailed composition, excellent lighting, and vibrant colors."
    
    return final_text

def send_request(t, l=[]):
    """Ø¥Ø±Ø³Ø§Ù„ Ø·Ù„Ø¨ Ø¥Ù„Ù‰ API SeedReam"""
    try:
        response = requests.post(SeedReam, data={"text": t, "links": ",".join(l)})
        return response.json().get("image")
    except:
        return None

def generate_prompt(text):
    """Ø¥Ù†Ø´Ø§Ø¡ Ø¨Ø±ÙˆÙ…Ø¨Øª Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… DeepSeek V3"""
    try:
        # Ø§Ø³ØªØ®Ø¯Ø§Ù… DeepSeek V3 Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¨Ø±ÙˆÙ…Ø¨Øª
        prompt_request = f"Create a detailed professional image generation prompt in English for: {text}. Make it long, descriptive, and include details about scene, lighting, colors, composition, and atmosphere. Return only the prompt text without any explanations, code blocks, or additional notes."
        response = requests.get(f"{DEEPSEEK_V3_API}{requests.utils.quote(prompt_request)}", timeout=20)
        
        if response.status_code == 200 and response.text.strip():
            clean_prompt = clean_prompt_text(response.text)
            return clean_prompt
        else:
            return f"Create a high-quality, detailed image of: {text}. Realistic details, vibrant colors, professional lighting, 4K resolution."
    except Exception as e:
        return f"Create a high-quality, detailed image of: {text}. Realistic details, vibrant colors, professional lighting, 4K resolution."

def generate_edit_prompt(text):
    """Ø¥Ù†Ø´Ø§Ø¡ Ø¨Ø±ÙˆÙ…Ø¨Øª ØªØ¹Ø¯ÙŠÙ„ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… DeepSeek R1"""
    try:
        # Ø§Ø³ØªØ®Ø¯Ø§Ù… DeepSeek R1 Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø¨Ø±ÙˆÙ…Ø¨Øª Ø§Ù„ØªØ¹Ø¯ÙŠÙ„
        prompt_request = f"Create a detailed professional image editing prompt in English for: {text}. Focus on specific modifications like color adjustments, lighting changes, background alterations, and technical improvements. Return only the prompt text without any explanations, code blocks, or additional notes."
        response = requests.post(
            DEEPSEEK_R1_API,
            data={"r1": prompt_request},
            timeout=20
        )
        
        if response.status_code == 200 and response.text.strip():
            clean_prompt = clean_prompt_text(response.text)
            return clean_prompt
        else:
            return f"Professional image editing for: {text}. Enhance quality, adjust colors, improve lighting, refine details."
    except Exception as e:
        return f"Professional image editing for: {text}. Enhance quality, adjust colors, improve lighting, refine details."

# Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø£ÙˆØ§Ù…Ø± ÙˆØ§Ù„Ø±Ø³Ø§Ø¦Ù„
@T.message_handler(commands=['start'])
def start_cmd(m):
    """Ù…Ø¹Ø§Ù„Ø¬ Ø£Ù…Ø± Ø§Ù„Ø¨Ø¯Ø¡"""
    uid = m.from_user.id
    
    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©
    if not check_subscription(uid):
        markup = InlineKeyboardMarkup()
        markup.add(InlineKeyboardButton("Ø§Ø´ØªØ±Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø© ğŸ“¢", url=f"https://t.me/{CHANNEL_USERNAME[1:]}"))
        markup.add(InlineKeyboardButton("ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ âœ…", callback_data="check_subscription"))
        T.send_message(uid, f"âš ï¸ ÙŠØ¬Ø¨ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ù‚Ù†Ø§ØªÙ†Ø§ Ø£ÙˆÙ„Ø§Ù‹ Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙˆØª:\n{CHANNEL_USERNAME}", reply_markup=markup)
        return
    
    markup = InlineKeyboardMarkup(row_width=1)
    emoji1 = get_random_emoji()
    emoji2 = get_random_emoji()
    markup.add(
        InlineKeyboardButton(f"Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø·Ø§Ù„Ø¨Ø© {emoji1}", callback_data="create_prompt_menu"),
        InlineKeyboardButton(f"Ø®Ø¯Ù…Ø§Øª Ø§Ù„Ø¨ÙˆØª {emoji2}", callback_data="bot_services")
    )
    T.send_message(uid, "Ø£Ù‡Ù„Ø§Ù‹! Ø£Ù†Ø§ @TeSi7_BOT Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø·Ø§Ù„Ø¨Ø§Øª ÙˆØ§Ù„ØµÙˆØ± ğŸŒ´", reply_markup=markup)

@T.callback_query_handler(func=lambda c: c.data == "check_subscription")
def check_subscription_callback(c):
    """Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø¹Ù†Ø¯ Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø²Ø±"""
    uid = c.from_user.id
    
    if check_subscription(uid):
        markup = InlineKeyboardMarkup(row_width=1)
        emoji1 = get_random_emoji()
        emoji2 = get_random_emoji()
        markup.add(
            InlineKeyboardButton(f"Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø·Ø§Ù„Ø¨Ø© {emoji1}", callback_data="create_prompt_menu"),
            InlineKeyboardButton(f"Ø®Ø¯Ù…Ø§Øª Ø§Ù„Ø¨ÙˆØª {emoji2}", callback_data="bot_services")
        )
        try:
            T.edit_message_text("Ø£Ù‡Ù„Ø§Ù‹! Ø£Ù†Ø§ @TeSi7_BOT Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø·Ø§Ù„Ø¨Ø§Øª ÙˆØ§Ù„ØµÙˆØ± ğŸŒ´", 
                              c.message.chat.id, c.message.message_id, reply_markup=markup)
        except:
            T.send_message(uid, "Ø£Ù‡Ù„Ø§Ù‹! Ø£Ù†Ø§ @TeSi7_BOT Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø·Ø§Ù„Ø¨Ø§Øª ÙˆØ§Ù„ØµÙˆØ± ğŸŒ´", reply_markup=markup)
    else:
        markup = InlineKeyboardMarkup()
        markup.add(InlineKeyboardButton("Ø§Ø´ØªØ±Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø© ğŸ“¢", url=f"https://t.me/{CHANNEL_USERNAME[1:]}"))
        markup.add(InlineKeyboardButton("ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ âœ…", callback_data="check_subscription"))
        try:
            T.edit_message_text(f"âš ï¸ Ù„Ù… ØªØ´ØªØ±Ùƒ Ø¨Ø¹Ø¯ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©:\n{CHANNEL_USERNAME}", 
                              c.message.chat.id, c.message.message_id, reply_markup=markup)
        except:
            T.send_message(uid, f"âš ï¸ Ù„Ù… ØªØ´ØªØ±Ùƒ Ø¨Ø¹Ø¯ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©:\n{CHANNEL_USERNAME}", reply_markup=markup)

@T.callback_query_handler(func=lambda c: c.data == "create_prompt_menu")
def create_prompt_menu(c):
    """Ù‚Ø§Ø¦Ù…Ø© Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø·Ø§Ù„Ø¨Ø§Øª"""
    uid = c.from_user.id
    
    if not check_subscription(uid):
        markup = InlineKeyboardMarkup()
        markup.add(InlineKeyboardButton("Ø§Ø´ØªØ±Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø© ğŸ“¢", url=f"https://t.me/{CHANNEL_USERNAME[1:]}"))
        markup.add(InlineKeyboardButton("ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ âœ…", callback_data="check_subscription"))
        try:
            T.edit_message_text(f"âš ï¸ ÙŠØ¬Ø¨ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ù‚Ù†Ø§ØªÙ†Ø§ Ø£ÙˆÙ„Ø§Ù‹:\n{CHANNEL_USERNAME}", 
                              c.message.chat.id, c.message.message_id, reply_markup=markup)
        except:
            T.send_message(uid, f"âš ï¸ ÙŠØ¬Ø¨ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ù‚Ù†Ø§ØªÙ†Ø§ Ø£ÙˆÙ„Ø§Ù‹:\n{CHANNEL_USERNAME}", reply_markup=markup)
        return
    
    markup = InlineKeyboardMarkup(row_width=1)
    emoji1 = get_random_emoji()
    emoji2 = get_random_emoji()
    markup.add(
        InlineKeyboardButton(f"Ù…Ø·Ø§Ù„Ø¨Ø© Ø¥Ù†Ø´Ø§Ø¡ {emoji1}", callback_data="create_prompt_type"),
        InlineKeyboardButton(f"Ù…Ø·Ø§Ù„Ø¨Ø© ØªØ¹Ø¯ÙŠÙ„ {emoji2}", callback_data="edit_prompt_type"),
        InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ ğŸ”™", callback_data="back_to_main")
    )
    try:
        T.edit_message_text("Ø§Ø®ØªØ± Ù†ÙˆØ¹ Ø§Ù„Ù…Ø·Ø§Ù„Ø¨Ø© Ø§Ù„ØªÙŠ ØªØ±ÙŠØ¯ Ø¥Ù†Ø´Ø§Ø¡Ù‡Ø§:", c.message.chat.id, c.message.message_id, reply_markup=markup)
    except:
        T.send_message(uid, "Ø§Ø®ØªØ± Ù†ÙˆØ¹ Ø§Ù„Ù…Ø·Ø§Ù„Ø¨Ø© Ø§Ù„ØªÙŠ ØªØ±ÙŠØ¯ Ø¥Ù†Ø´Ø§Ø¡Ù‡Ø§:", reply_markup=markup)

@T.callback_query_handler(func=lambda c: c.data == "bot_services")
def bot_services(c):
    """Ù‚Ø§Ø¦Ù…Ø© Ø®Ø¯Ù…Ø§Øª Ø§Ù„Ø¨ÙˆØª"""
    uid = c.from_user.id
    
    if not check_subscription(uid):
        markup = InlineKeyboardMarkup()
        markup.add(InlineKeyboardButton("Ø§Ø´ØªØ±Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø© ğŸ“¢", url=f"https://t.me/{CHANNEL_USERNAME[1:]}"))
        markup.add(InlineKeyboardButton("ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ âœ…", callback_data="check_subscription"))
        try:
            T.edit_message_text(f"âš ï¸ ÙŠØ¬Ø¨ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ù‚Ù†Ø§ØªÙ†Ø§ Ø£ÙˆÙ„Ø§Ù‹:\n{CHANNEL_USERNAME}", 
                              c.message.chat.id, c.message.message_id, reply_markup=markup)
        except:
            T.send_message(uid, f"âš ï¸ ÙŠØ¬Ø¨ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ù‚Ù†Ø§ØªÙ†Ø§ Ø£ÙˆÙ„Ø§Ù‹:\n{CHANNEL_USERNAME}", reply_markup=markup)
        return
    
    markup = InlineKeyboardMarkup(row_width=1)
    emoji1 = get_random_emoji()
    emoji2 = get_random_emoji()
    markup.add(
        InlineKeyboardButton(f"Ø¥Ù†Ø´Ø§Ø¡ ØµÙˆØ±Ø© {emoji1}", callback_data="create_img"),
        InlineKeyboardButton(f"ØªØ¹Ø¯ÙŠÙ„ ØµÙˆØ±Ø© {emoji2}", callback_data="edit_img"),
        InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ ğŸ”™", callback_data="back_to_main")
    )
    try:
        T.edit_message_text("Ø§Ø®ØªØ± Ø§Ù„Ø®Ø¯Ù…Ø© Ø§Ù„ØªÙŠ ØªØ±ÙŠØ¯Ù‡Ø§:", c.message.chat.id, c.message.message_id, reply_markup=markup)
    except:
        T.send_message(uid, "Ø§Ø®ØªØ± Ø§Ù„Ø®Ø¯Ù…Ø© Ø§Ù„ØªÙŠ ØªØ±ÙŠØ¯Ù‡Ø§:", reply_markup=markup)

@T.callback_query_handler(func=lambda c: c.data == "back_to_main")
def back_to_main(c):
    """Ø§Ù„Ø¹ÙˆØ¯Ø© Ø¥Ù„Ù‰ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"""
    uid = c.from_user.id
    
    if not check_subscription(uid):
        markup = InlineKeyboardMarkup()
        markup.add(InlineKeyboardButton("Ø§Ø´ØªØ±Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø© ğŸ“¢", url=f"https://t.me/{CHANNEL_USERNAME[1:]}"))
        markup.add(InlineKeyboardButton("ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ âœ…", callback_data="check_subscription"))
        try:
            T.edit_message_text(f"âš ï¸ ÙŠØ¬Ø¨ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ù‚Ù†Ø§ØªÙ†Ø§ Ø£ÙˆÙ„Ø§Ù‹:\n{CHANNEL_USERNAME}", 
                              c.message.chat.id, c.message.message_id, reply_markup=markup)
        except:
            T.send_message(uid, f"âš ï¸ ÙŠØ¬Ø¨ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ù‚Ù†Ø§ØªÙ†Ø§ Ø£ÙˆÙ„Ø§Ù‹:\n{CHANNEL_USERNAME}", reply_markup=markup)
        return
    
    markup = InlineKeyboardMarkup(row_width=1)
    emoji1 = get_random_emoji()
    emoji2 = get_random_emoji()
    markup.add(
        InlineKeyboardButton(f"Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø·Ø§Ù„Ø¨Ø© {emoji1}", callback_data="create_prompt_menu"),
        InlineKeyboardButton(f"Ø®Ø¯Ù…Ø§Øª Ø§Ù„Ø¨ÙˆØª {emoji2}", callback_data="bot_services")
    )
    try:
        T.edit_message_text("Ø£Ù‡Ù„Ø§Ù‹! Ø£Ù†Ø§ @TeSi7_BOT Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø·Ø§Ù„Ø¨Ø§Øª ÙˆØ§Ù„ØµÙˆØ± ğŸŒ´", 
                          c.message.chat.id, c.message.message_id, reply_markup=markup)
    except:
        T.send_message(uid, "Ø£Ù‡Ù„Ø§Ù‹! Ø£Ù†Ø§ @TeSi7_BOT Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø·Ø§Ù„Ø¨Ø§Øª ÙˆØ§Ù„ØµÙˆØ± ğŸŒ´", reply_markup=markup)

@T.callback_query_handler(func=lambda c: c.data in ["create_prompt_type", "edit_prompt_type", "create_img", "edit_img"])
def action_select(c):
    """Ø§Ø®ØªÙŠØ§Ø± Ù†ÙˆØ¹ Ø§Ù„Ø®Ø¯Ù…Ø©"""
    uid = c.from_user.id
    
    if not check_subscription(uid):
        markup = InlineKeyboardMarkup()
        markup.add(InlineKeyboardButton("Ø§Ø´ØªØ±Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø© ğŸ“¢", url=f"https://t.me/{CHANNEL_USERNAME[1:]}"))
        markup.add(InlineKeyboardButton("ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ âœ…", callback_data="check_subscription"))
        try:
            T.edit_message_text(f"âš ï¸ ÙŠØ¬Ø¨ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ù‚Ù†Ø§ØªÙ†Ø§ Ø£ÙˆÙ„Ø§Ù‹:\n{CHANNEL_USERNAME}", 
                              c.message.chat.id, c.message.message_id, reply_markup=markup)
        except:
            T.send_message(uid, f"âš ï¸ ÙŠØ¬Ø¨ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ù‚Ù†Ø§ØªÙ†Ø§ Ø£ÙˆÙ„Ø§Ù‹:\n{CHANNEL_USERNAME}", reply_markup=markup)
        return
    
    user_action[c.from_user.id] = c.data
    
    if c.data == "create_prompt_type":
        text = "Ø£Ø±Ø³Ù„ ÙˆØµÙ Ø§Ù„ØµÙˆØ±Ø© Ù„Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø·Ø§Ù„Ø¨Ø© Ø¥Ù†Ø´Ø§Ø¡ Ø§Ø­ØªØ±Ø§ÙÙŠØ©"
        back_data = "create_prompt_menu"
    elif c.data == "edit_prompt_type":
        text = "Ø£Ø±Ø³Ù„ ÙˆØµÙ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ Ù„Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø·Ø§Ù„Ø¨Ø© ØªØ¹Ø¯ÙŠÙ„ Ø§Ø­ØªØ±Ø§ÙÙŠØ©"
        back_data = "create_prompt_menu"
    elif c.data == "create_img":
        text = "Ø£Ø±Ø³Ù„ ÙˆØµÙ Ø§Ù„ØµÙˆØ±Ø©"
        back_data = "bot_services"
    else:  # edit_img
        text = "Ø£Ø±Ø³Ù„ Ø§Ù„ØµÙˆØ±Ø© (Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ 4)"
        back_data = "bot_services"
    
    markup = InlineKeyboardMarkup()
    markup.add(InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ ğŸ”™", callback_data=back_data))
    
    try:
        T.edit_message_text(text, c.message.chat.id, c.message.message_id, reply_markup=markup)
    except:
        T.send_message(uid, text, reply_markup=markup)

@T.message_handler(content_types=['photo'])
def handle_photos(m):
    """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ± Ø§Ù„Ù…Ø±Ø³Ù„Ø© Ù„Ù„ØªØ¹Ø¯ÙŠÙ„"""
    uid = m.from_user.id
    
    if not check_subscription(uid):
        markup = InlineKeyboardMarkup()
        markup.add(InlineKeyboardButton("Ø§Ø´ØªØ±Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø© ğŸ“¢", url=f"https://t.me/{CHANNEL_USERNAME[1:]}"))
        markup.add(InlineKeyboardButton("ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ âœ…", callback_data="check_subscription"))
        T.send_message(uid, f"âš ï¸ ÙŠØ¬Ø¨ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ù‚Ù†Ø§ØªÙ†Ø§ Ø£ÙˆÙ„Ø§Ù‹:\n{CHANNEL_USERNAME}", reply_markup=markup)
        return
    
    if user_action.get(uid) != "edit_img":
        return
        
    user_photos.setdefault(uid, []).append(m.photo[-1].file_id)
    if len(user_photos[uid]) > 4:
        user_photos[uid] = user_photos[uid][:4]
    if len(user_photos[uid]) == 1:
        markup = InlineKeyboardMarkup()
        markup.add(InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ ğŸ”™", callback_data="bot_services"))
        T.send_message(uid, "Ø£Ø±Ø³Ù„ ÙˆØµÙ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„", reply_markup=markup)

@T.message_handler(func=lambda m: True)
def handle_description(m):
    """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù†ØµÙˆØµ Ø§Ù„Ù…Ø±Ø³Ù„Ø©"""
    uid = m.from_user.id
    
    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©
    if not check_subscription(uid):
        markup = InlineKeyboardMarkup()
        markup.add(InlineKeyboardButton("Ø§Ø´ØªØ±Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø© ğŸ“¢", url=f"https://t.me/{CHANNEL_USERNAME[1:]}"))
        markup.add(InlineKeyboardButton("ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ âœ…", callback_data="check_subscription"))
        T.send_message(uid, f"âš ï¸ ÙŠØ¬Ø¨ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ù‚Ù†Ø§ØªÙ†Ø§ Ø£ÙˆÙ„Ø§Ù‹:\n{CHANNEL_USERNAME}", reply_markup=markup)
        return
    
    action = user_action.get(uid)
    
    if action == "edit_img" and uid in user_photos and user_photos[uid]:
        # Ù…Ø¹Ø§Ù„Ø¬Ø© ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©
        wait_st = T.send_sticker(uid, "CAACAgIAAxkBAAIMcmjDndyMvCb2OBQhIGobGVZU4f6JAAK0IwACmEspSN65vs0qW-TZNgQ")
        desc = m.text
        links = [f"https://api.telegram.org/file/bot{T.token}/{T.get_file(fid).file_path}" for fid in user_photos[uid]]
        cap = (desc[:1021] + "...") if len(desc) > 1024 else desc
        
        with ThreadPoolExecutor() as e:
            results = list(e.map(lambda _: send_request(desc, links), range(2)))
        
        media = []
        for i, u in enumerate(results):
            if not u:
                continue
            if i == 0:
                media.append(InputMediaPhoto(media=u, caption=f"<b><blockquote>{cap}</blockquote></b>", parse_mode="HTML", has_spoiler=True))
            else:
                media.append(InputMediaPhoto(media=u, has_spoiler=True))
        
        if media:
            T.send_media_group(uid, media)
        
        try:
            T.delete_message(uid, wait_st.message_id)
        except:
            pass
        
        user_photos[uid] = []
        user_action.pop(uid, None)
        
        # Ø¥Ø¸Ù‡Ø§Ø± Ø²Ø± Ø§Ù„Ø¹ÙˆØ¯Ø© Ø¨Ø¹Ø¯ Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡
        markup = InlineKeyboardMarkup()
        markup.add(InlineKeyboardButton("Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ø®Ø¯Ù…Ø§Øª ğŸ”™", callback_data="bot_services"))
        T.send_message(uid, "ØªÙ… Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡ Ù…Ù† Ø§Ù„ØªØ¹Ø¯ÙŠÙ„! ğŸ‰", reply_markup=markup)
        
    elif action == "create_img":
        # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØµÙˆØ±Ø©
        wait_st = T.send_sticker(uid, "CAACAgIAAxkBAAIMcmjDndyMvCb2OBQhIGobGVZU4f6JAAK0IwACmEspSN65vs0qW-TZNgQ")
        desc = m.text
        cap = (desc[:1021] + "...") if len(desc) > 1024 else desc
        
        with ThreadPoolExecutor() as e:
            results = list(e.map(lambda _: send_request(desc), range(2)))
        
        media = []
        for i, u in enumerate(results):
            if not u:
                continue
            if i == 0:
                media.append(InputMediaPhoto(media=u, caption=f"<b><blockquote>{cap}</blockquote></b>", parse_mode="HTML", has_spoiler=True))
            else:
                media.append(InputMediaPhoto(media=u, has_spoiler=True))
        
        if media:
            T.send_media_group(uid, media)
        
        try:
            T.delete_message(uid, wait_st.message_id)
        except:
            pass
        
        user_action.pop(uid, None)
        
        # Ø¥Ø¸Ù‡Ø§Ø± Ø²Ø± Ø§Ù„Ø¹ÙˆØ¯Ø© Ø¨Ø¹Ø¯ Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡
        markup = InlineKeyboardMarkup()
        markup.add(InlineKeyboardButton("Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ø®Ø¯Ù…Ø§Øª ğŸ”™", callback_data="bot_services"))
        T.send_message(uid, "ØªÙ… Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡ Ù…Ù† Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡! ğŸ‰", reply_markup=markup)
        
    elif action == "create_prompt_type":
        # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¥Ù†Ø´Ø§Ø¡ Ø¨Ø±ÙˆÙ…Ø¨Øª Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡
        wait_st = T.send_sticker(uid, "CAACAgIAAxkBAAIMcmjDndyMvCb2OBQhIGobGVZU4f6JAAK0IwACmEspSN65vs0qW-TZNgQ")
        prompt_text = m.text
        
        # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¨Ø±ÙˆÙ…Ø¨Øª Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ
        generated_prompt = generate_prompt(prompt_text)
        
        # Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨Ø±ÙˆÙ…Ø¨Øª ÙÙ‚Ø· Ø¨Ø´ÙƒÙ„ Ù…Ø§Ø±ÙƒØ¯Ø§ÙˆÙ† Ø¨Ø¯ÙˆÙ† Ø±Ù…ÙˆØ² Ø¨Ø±Ù…Ø¬ÙŠØ©
        T.send_message(uid, f"```\n{generated_prompt}\n```", parse_mode="Markdown")
        
        try:
            T.delete_message(uid, wait_st.message_id)
        except:
            pass
        
        user_action.pop(uid, None)
        
        # Ø¥Ø¸Ù‡Ø§Ø± Ø²Ø± Ø§Ù„Ø¹ÙˆØ¯Ø© Ø¨Ø¹Ø¯ Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡
        markup = InlineKeyboardMarkup()
        markup.add(InlineKeyboardButton("Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© ğŸ”™", callback_data="create_prompt_menu"))
        T.send_message(uid, "ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø·Ø§Ù„Ø¨Ø© Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø¨Ù†Ø¬Ø§Ø­! ğŸ‰", reply_markup=markup)
        
    elif action == "edit_prompt_type":
        # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¥Ù†Ø´Ø§Ø¡ Ø¨Ø±ÙˆÙ…Ø¨Øª Ø§Ù„ØªØ¹Ø¯ÙŠÙ„
        wait_st = T.send_sticker(uid, "CAACAgIAAxkBAAIMcmjDndyMvCb2OBQhIGobGVZU4f6JAAK0IwACmEspSN65vs0qW-TZNgQ")
        prompt_text = m.text
        
        # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¨Ø±ÙˆÙ…Ø¨Øª Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ
        generated_prompt = generate_edit_prompt(prompt_text)
        
        # Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨Ø±ÙˆÙ…Ø¨Øª ÙÙ‚Ø· Ø¨Ø´ÙƒÙ„ Ù…Ø§Ø±ÙƒØ¯Ø§ÙˆÙ† Ø¨Ø¯ÙˆÙ† Ø±Ù…ÙˆØ² Ø¨Ø±Ù…Ø¬ÙŠØ©
        T.send_message(uid, f"```\n{generated_prompt}\n```", parse_mode="Markdown")
        
        try:
            T.delete_message(uid, wait_st.message_id)
        except:
            pass
        
        user_action.pop(uid, None)
        
        # Ø¥Ø¸Ù‡Ø§Ø± Ø²Ø± Ø§Ù„Ø¹ÙˆØ¯Ø© Ø¨Ø¹Ø¯ Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡
        markup = InlineKeyboardMarkup()
        markup.add(InlineKeyboardButton("Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© ğŸ”™", callback_data="create_prompt_menu"))
        T.send_message(uid, "ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø·Ø§Ù„Ø¨Ø© Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ø¨Ù†Ø¬Ø§Ø­! ğŸ‰", reply_markup=markup)

# Ø¥Ø¹Ø¯Ø§Ø¯ ÙˆÙŠØ¨ Ù‡ÙˆÙˆÙƒ
WEBHOOK_URL = "https://yemen9-1.onrender.com"
WEBHOOK_PATH = "/webhook"

@app.route(WEBHOOK_PATH, methods=['POST'])
def webhook():
    """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ÙˆÙŠØ¨ Ù‡ÙˆÙˆÙƒ"""
    if request.headers.get('content-type') == 'application/json':
        json_string = request.get_data().decode('utf-8')
        update = telebot.types.Update.de_json(json_string)
        T.process_new_updates([update])
        return ''
    else:
        return 'Invalid content type', 403

@app.route('/')
def index():
    """Ø§Ù„ØµÙØ­Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ù„Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ ØªØ´ØºÙŠÙ„ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚"""
    return "Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„ Ø¨Ø´ÙƒÙ„ Ø·Ø¨ÙŠØ¹ÙŠ! ğŸš€"

@app.route('/health')
def health_check():
    """ÙØ­Øµ ØµØ­Ø© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚"""
    return "OK", 200

def set_webhook():
    """ØªØ¹ÙŠÙŠÙ† Ø§Ù„ÙˆÙŠØ¨ Ù‡ÙˆÙˆÙƒ"""
    try:
        T.remove_webhook()
        time.sleep(1)
        T.set_webhook(url=WEBHOOK_URL + WEBHOOK_PATH)
        print(f"ØªÙ… ØªØ¹ÙŠÙŠÙ† Ø§Ù„ÙˆÙŠØ¨ Ù‡ÙˆÙˆÙƒ Ø¹Ù„Ù‰: {WEBHOOK_URL + WEBHOOK_PATH}")
    except Exception as e:
        print(f"Ø®Ø·Ø£ ÙÙŠ ØªØ¹ÙŠÙŠÙ† Ø§Ù„ÙˆÙŠØ¨ Ù‡ÙˆÙˆÙƒ: {e}")

def keep_alive():
    """Ø¥Ø±Ø³Ø§Ù„ Ø·Ù„Ø¨Ø§Øª Ø¯ÙˆØ±ÙŠØ© Ù„Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ù†Ø´Ø·Ø§Ù‹"""
    while True:
        try:
            requests.get(WEBHOOK_URL)
            print("ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø·Ù„Ø¨ Ù„Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„Ù†Ø´Ø§Ø·")
        except Exception as e:
            print(f"Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø·Ù„Ø¨ Ø§Ù„Ù†Ø´Ø§Ø·: {e}")
        time.sleep(300)  # Ø§Ù†ØªØ¸Ø± 5 Ø¯Ù‚Ø§Ø¦Ù‚ Ø¨ÙŠÙ† ÙƒÙ„ Ø·Ù„Ø¨

if __name__ == "__main__":
    # ØªØ¹ÙŠÙŠÙ† Ø§Ù„ÙˆÙŠØ¨ Ù‡ÙˆÙˆÙƒ Ø¹Ù†Ø¯ Ø§Ù„ØªØ´ØºÙŠÙ„
    set_webhook()
    
    # Ø¨Ø¯Ø¡ Ø®ÙŠØ· Ù„Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„Ù†Ø´Ø§Ø·
    keep_alive_thread = threading.Thread(target=keep_alive, daemon=True)
    keep_alive_thread.start()
    
    # ØªØ´ØºÙŠÙ„ ØªØ·Ø¨ÙŠÙ‚ Flask
    app.run(host='0.0.0.0', port=10000, debug=False)
